<!DOCTYPE html>
<html lang="lt">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AtomChain: Dinaminė Atomų Evoliucija</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: radial-gradient(circle at center, #0f0f23, #1a1a2e, #000);
        color: white;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        max-width: 1600px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        background: linear-gradient(45deg, #667eea, #764ba2, #ffd700);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 2.5em;
        margin: 0;
      }

      .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      }

      button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
      }

      .visualization-container {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }

      .main-viz {
        flex: 3;
        background: rgba(15, 15, 35, 0.9);
        border-radius: 20px;
        padding: 20px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(102, 126, 234, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      .side-panel {
        flex: 1;
        background: rgba(15, 15, 35, 0.9);
        border-radius: 20px;
        padding: 20px;
        backdrop-filter: blur(10px);
        max-height: 600px;
        overflow-y: auto;
        border: 1px solid rgba(102, 126, 234, 0.3);
      }

      #atomCanvas {
        width: 100%;
        height: 600px;
        border-radius: 15px;
        background: radial-gradient(
          circle at center,
          rgba(15, 15, 35, 0.8),
          rgba(0, 0, 0, 0.9)
        );
        border: 2px solid rgba(102, 126, 234, 0.2);
      }

      .atom-info {
        margin-bottom: 15px;
        padding: 12px;
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.1),
          rgba(118, 75, 162, 0.1)
        );
        border-radius: 10px;
        font-size: 11px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .state-display {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        margin: 8px 0;
      }

      .state-val {
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 9px;
        text-align: center;
        font-weight: bold;
      }

      .state-x {
        background: linear-gradient(45deg, #ff6b6b, #ee5a52);
      }
      .state-y {
        background: linear-gradient(45deg, #4ecdc4, #44a08d);
      }
      .state-energy {
        background: linear-gradient(45deg, #ffd700, #ffb347);
      }

      .links-display {
        color: #90ee90;
        font-size: 10px;
        margin: 5px 0;
      }

      .metadata-display {
        color: #dda0dd;
        font-size: 9px;
        font-style: italic;
        background: rgba(221, 160, 221, 0.1);
        padding: 4px;
        border-radius: 4px;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .stat-card {
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.1),
          rgba(118, 75, 162, 0.1)
        );
        padding: 15px;
        border-radius: 15px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
      }

      .stat-number {
        font-size: 2em;
        font-weight: bold;
        margin: 10px 0;
      }

      .parameter-controls {
        background: rgba(15, 15, 35, 0.9);
        border-radius: 15px;
        padding: 15px;
        margin-top: 20px;
        border: 1px solid rgba(102, 126, 234, 0.3);
      }

      .slider-group {
        margin: 10px 0;
      }

      .slider-group label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #ccc;
      }

      input[type='range'] {
        width: 100%;
        margin: 5px 0;
      }

      .evolution-trail {
        opacity: 0.3;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>⚛️ AtomChain: Dinaminė Evoliucija</h1>
      </div>

      <div class="controls">
        <button onclick="startEvolution()">🌊 Paleisti evoliuciją</button>
        <button onclick="pauseEvolution()">⏸️ Pristabdyti</button>
        <button onclick="resetSystem()">🔄 Naujas pasaulis</button>
        <button onclick="addEnergyWave()">⚡ Energijos banga</button>
        <button onclick="createGravityWell()">🕳️ Gravitacijos šulinys</button>
        <button onclick="toggleTrails()">✨ Trajektorijos</button>
      </div>

      <div class="visualization-container">
        <div class="main-viz">
          <svg id="atomCanvas" viewBox="0 0 1000 600">
            <defs>
              <radialGradient id="atomGlow" cx="50%" cy="50%" r="50%">
                <stop
                  offset="0%"
                  style="stop-color: rgba(255, 255, 255, 0.8); stop-opacity: 1"
                />
                <stop
                  offset="70%"
                  style="stop-color: rgba(102, 126, 234, 0.6); stop-opacity: 1"
                />
                <stop
                  offset="100%"
                  style="stop-color: rgba(102, 126, 234, 0); stop-opacity: 0"
                />
              </radialGradient>
              <filter id="glow">
                <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                <feMerge>
                  <feMergeNode in="coloredBlur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>
          </svg>
        </div>

        <div class="side-panel">
          <h3>🎛️ Parametrai</h3>
          <div class="parameter-controls">
            <div class="slider-group">
              <label>Mutacijos jėga: <span id="mutationValue">0.1</span></label>
              <input
                type="range"
                id="mutationSlider"
                min="0"
                max="0.5"
                step="0.01"
                value="0.1"
                oninput="updateMutation()"
              />
            </div>
            <div class="slider-group">
              <label>Gravitacija: <span id="gravityValue">0.02</span></label>
              <input
                type="range"
                id="gravitySlider"
                min="0"
                max="0.1"
                step="0.001"
                value="0.02"
                oninput="updateGravity()"
              />
            </div>
            <div class="slider-group">
              <label
                >Energijos sklaida: <span id="dampingValue">0.99</span></label
              >
              <input
                type="range"
                id="dampingSlider"
                min="0.9"
                max="1"
                step="0.001"
                value="0.99"
                oninput="updateDamping()"
              />
            </div>
          </div>

          <h3>📊 Sistema</h3>
          <div id="systemInfo"></div>

          <h3>⚛️ Aktyvūs atomai</h3>
          <div id="atomsList"></div>
        </div>
      </div>

      <div class="stats">
        <div class="stat-card">
          <h4>🎯 Deterministiniai</h4>
          <div class="stat-number" id="deterministicActions">0</div>
        </div>
        <div class="stat-card">
          <h4>🔄 Adaptyvūs</h4>
          <div class="stat-number" id="adaptiveActions">0</div>
        </div>
        <div class="stat-card">
          <h4>🎲 Pseudo-random</h4>
          <div class="stat-number" id="pseudoRandomActions">0</div>
        </div>
        <div class="stat-card">
          <h4>⚡ Vidutinė energija</h4>
          <div class="stat-number" id="avgEnergy">50.0</div>
        </div>
        <div class="stat-card">
          <h4>🌐 Aktyvūs ryšiai</h4>
          <div class="stat-number" id="activeLinks">0</div>
        </div>
      </div>
    </div>

    <script>
      class Atom {
        constructor(id) {
          this.id = id;
          // State kontroliuoja viską: [x_koord, y_koord, energija, gravitacija, spalva_komponentas]
          this.state = [
            Math.random() * 800 + 100, // x koordinatė (100-900)
            Math.random() * 400 + 100, // y koordinatė (100-500)
            Math.random() * 100 + 20, // energija (20-120)
            Math.random() * 50, // gravitacijos jėga (0-50)
            Math.random() * 360, // spalvos hue (0-360)
          ];
          this.velocity = [0, 0]; // greičio vektorius
          this.links = [];
          this.metadata = this.generateMetadata();
          this.trail = []; // trajektorijos taškai
          this.adaptationCount = 0;
          this.lastDecisionType = 'deterministic';
          this.age = 0;
          this.maxTrailLength = 20;
        }

        generateMetadata() {
          const behaviors = [
            'orbital_dancer', // orbitiniu judesimu
            'energy_vampire', // absorbuoja energija
            'gravity_well', // traukia kitus
            'wanderer', // klajoja laisvai
            'cluster_former', // formuoja grupes
            'boundary_keeper', // budi ribose
          ];
          return behaviors[Math.floor(Math.random() * behaviors.length)];
        }

        // Pagrindinė evoliucijos logika
        evolve(atoms, systemParams) {
          this.age++;

          // Trajektorijos sekimas
          this.updateTrail();

          // Fizikos taisyklės pagal state[]
          this.applyPhysics(atoms, systemParams);

          // Hibridinis sprendimas
          const decision = this.makeDecision(atoms, systemParams);

          // Mutacijos ir adaptacija
          this.mutate(systemParams.mutationRate);

          // Ribų kontrolė
          this.enforceboundaries();

          return decision;
        }

        applyPhysics(atoms, params) {
          // Gravitacinis poveikis tarp atomų
          atoms.forEach((other) => {
            if (other.id === this.id) return;

            const dx = other.state[0] - this.state[0];
            const dy = other.state[1] - this.state[1];
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 5) {
              // vengti dalijimo iš nulio
              // Gravitacijos jėga proporcinga atomų energijai
              const force =
                ((this.state[3] * other.state[3]) / (distance * distance)) *
                params.gravity;

              this.velocity[0] += (dx / distance) * force;
              this.velocity[1] += (dy / distance) * force;
            }
          });

          // Energijos sklaida (damping)
          this.velocity[0] *= params.damping;
          this.velocity[1] *= params.damping;

          // Atnaujinti koordinates
          this.state[0] += this.velocity[0];
          this.state[1] += this.velocity[1];

          // Energijos kaita
          const energyLoss =
            Math.sqrt(
              this.velocity[0] * this.velocity[0] +
                this.velocity[1] * this.velocity[1]
            ) * 0.1;
          this.state[2] = Math.max(10, this.state[2] - energyLoss);
        }

        makeDecision(atoms, params) {
          const context = this.analyzeEnvironment(atoms);

          // Sprendimo tipas priklauso nuo konteksto ir metadata
          let decisionType = 'deterministic';

          if (
            this.metadata === 'energy_vampire' &&
            context.nearbyEnergy > this.state[2]
          ) {
            decisionType = 'adaptive';
          } else if (this.metadata === 'wanderer' && Math.random() < 0.3) {
            decisionType = 'pseudo_random';
          } else if (context.crowded && this.metadata === 'boundary_keeper') {
            decisionType = 'adaptive';
          }

          return this.executeDecision(decisionType, atoms, context);
        }

        executeDecision(type, atoms, context) {
          this.lastDecisionType = type;

          switch (type) {
            case 'deterministic':
              return this.deterministicBehavior(atoms);
            case 'adaptive':
              return this.adaptiveBehavior(atoms, context);
            case 'pseudo_random':
              return this.pseudoRandomBehavior(atoms);
          }
        }

        deterministicBehavior(atoms) {
          // Elgesys pagal metadata
          switch (this.metadata) {
            case 'orbital_dancer':
              // Orbitinis judejimas apie artimiausią atomą
              const nearest = this.findNearestAtom(atoms);
              if (nearest) {
                const angle = Math.atan2(
                  this.state[1] - nearest.state[1],
                  this.state[0] - nearest.state[0]
                );
                this.velocity[0] += Math.cos(angle + Math.PI / 2) * 0.2;
                this.velocity[1] += Math.sin(angle + Math.PI / 2) * 0.2;
              }
              break;

            case 'cluster_former':
              // Traukiasi prie panašių atomų
              const similar = atoms.filter(
                (a) =>
                  a.id !== this.id && Math.abs(a.state[2] - this.state[2]) < 30
              );
              if (similar.length > 0) {
                const target = similar[0];
                const dx = target.state[0] - this.state[0];
                const dy = target.state[1] - this.state[1];
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 50) {
                  this.velocity[0] += (dx / distance) * 0.1;
                  this.velocity[1] += (dy / distance) * 0.1;
                }
              }
              break;
          }
          return { type: 'deterministic', behavior: this.metadata };
        }

        adaptiveBehavior(atoms, context) {
          this.adaptationCount++;

          switch (this.metadata) {
            case 'energy_vampire':
              // Absorbuoja energiją iš artimų atomų
              atoms.forEach((other) => {
                const distance = this.distanceTo(other);
                if (distance < 80 && other.state[2] > this.state[2]) {
                  const energyTransfer =
                    Math.min(5, other.state[2] - this.state[2]) * 0.1;
                  this.state[2] += energyTransfer;
                  other.state[2] -= energyTransfer;

                  // Spalvos kaita
                  this.state[4] = (this.state[4] + 10) % 360;
                }
              });
              break;

            case 'boundary_keeper':
              // Jei per daug susispietė, stumia atomus
              if (context.crowded) {
                this.state[3] += 5; // padidina gravitacijos jėgą
                this.state[4] = (this.state[4] + 180) % 360; // keičia spalvą
              }
              break;

            case 'gravity_well':
              // Dinamiškai keičia gravitacijos jėgą
              this.state[3] = Math.min(
                100,
                this.state[3] + context.nearbyCount * 2
              );
              break;
          }

          return { type: 'adaptive', behavior: this.metadata, context };
        }

        pseudoRandomBehavior(atoms) {
          // Kontroliuojamas atsitiktinumas su hash pagrindu
          const seed = this.state[0] + this.state[1] + this.age;
          const hash = this.simpleHash(seed);

          // Pseudo-atsitiktinis impulso pridėjimas
          const angle = (hash % 628) / 100; // 0-2π
          const magnitude = ((hash % 100) / 100) * 2;

          this.velocity[0] += Math.cos(angle) * magnitude;
          this.velocity[1] += Math.sin(angle) * magnitude;

          // Spalvos kaita
          this.state[4] = (this.state[4] + (hash % 60)) % 360;

          return { type: 'pseudo_random', hash, angle, magnitude };
        }

        mutate(rate) {
          // Atsitiktinės mutacijos state[] vertėse
          for (let i = 2; i < this.state.length; i++) {
            // neliečiam koordinačių
            if (Math.random() < rate) {
              const change = (Math.random() - 0.5) * 10;
              this.state[i] = Math.max(0, this.state[i] + change);

              // Specialūs apribojimai
              if (i === 4) this.state[i] = this.state[i] % 360; // spalva 0-360
              if (i === 2)
                this.state[i] = Math.max(10, Math.min(150, this.state[i])); // energija 10-150
            }
          }
        }

        updateTrail() {
          this.trail.push({ x: this.state[0], y: this.state[1] });
          if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
          }
        }

        analyzeEnvironment(atoms) {
          const nearby = atoms.filter(
            (a) => a.id !== this.id && this.distanceTo(a) < 100
          );

          return {
            nearbyCount: nearby.length,
            crowded: nearby.length > 5,
            nearbyEnergy:
              nearby.reduce((sum, a) => sum + a.state[2], 0) /
              Math.max(1, nearby.length),
            isolation: nearby.length === 0,
          };
        }

        findNearestAtom(atoms) {
          let nearest = null;
          let minDistance = Infinity;

          atoms.forEach((atom) => {
            if (atom.id !== this.id) {
              const dist = this.distanceTo(atom);
              if (dist < minDistance) {
                minDistance = dist;
                nearest = atom;
              }
            }
          });

          return nearest;
        }

        distanceTo(other) {
          const dx = this.state[0] - other.state[0];
          const dy = this.state[1] - other.state[1];
          return Math.sqrt(dx * dx + dy * dy);
        }

        enforceboundaries() {
          const margin = 50;

          if (this.state[0] < margin) {
            this.state[0] = margin;
            this.velocity[0] = Math.abs(this.velocity[0]);
          }
          if (this.state[0] > 950) {
            this.state[0] = 950;
            this.velocity[0] = -Math.abs(this.velocity[0]);
          }
          if (this.state[1] < margin) {
            this.state[1] = margin;
            this.velocity[1] = Math.abs(this.velocity[1]);
          }
          if (this.state[1] > 550) {
            this.state[1] = 550;
            this.velocity[1] = -Math.abs(this.velocity[1]);
          }
        }

        simpleHash(input) {
          let hash = 0;
          const str = input.toString();
          for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash + str.charCodeAt(i)) & 0xffffffff;
          }
          return Math.abs(hash);
        }

        // Vizualinės savybės pagal state[]
        getSize() {
          return Math.max(3, Math.min(15, this.state[2] / 8));
        }

        getColor() {
          const hue = this.state[4];
          const saturation = Math.min(100, this.state[2]);
          const lightness = 40 + (this.state[3] / 100) * 30;
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        getOpacity() {
          return Math.max(0.3, Math.min(1, this.state[2] / 100));
        }
      }

      class AtomChainSystem {
        constructor() {
          this.atoms = [];
          this.evolutionRunning = false;
          this.showTrails = false;
          this.stats = {
            deterministicActions: 0,
            adaptiveActions: 0,
            pseudoRandomActions: 0,
          };
          this.params = {
            mutationRate: 0.1,
            gravity: 0.02,
            damping: 0.99,
          };
          this.initialize();
        }

        initialize() {
          this.atoms = [];
          // Sukuriame 30 atomų su skirtingais elgesiais
          for (let i = 0; i < 30; i++) {
            this.atoms.push(new Atom(i));
          }
          this.render();
        }

        evolve() {
          if (!this.evolutionRunning) return;

          const decisions = [];

          // Kiekvieno atomo evoliucija
          this.atoms.forEach((atom) => {
            const decision = atom.evolve(this.atoms, this.params);
            if (decision) {
              decisions.push({ atom: atom.id, decision });
              this.updateStats(decision.type);
            }
          });

          this.render();
          setTimeout(() => this.evolve(), 50); // 20 FPS
        }

        render() {
          const canvas = document.getElementById('atomCanvas');
          canvas.innerHTML = `
                    <defs>
                        <radialGradient id="atomGlow" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" style="stop-color:rgba(255,255,255,0.8);stop-opacity:1" />
                            <stop offset="70%" style="stop-color:rgba(102,126,234,0.6);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:rgba(102,126,234,0);stop-opacity:0" />
                        </radialGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge> 
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                `;

          // Piešiame trajektorijas
          if (this.showTrails) {
            this.atoms.forEach((atom) => {
              if (atom.trail.length > 1) {
                const path = atom.trail
                  .map(
                    (point, index) =>
                      `${index === 0 ? 'M' : 'L'} ${point.x} ${point.y}`
                  )
                  .join(' ');

                const trailElement = document.createElementNS(
                  'http://www.w3.org/2000/svg',
                  'path'
                );
                trailElement.setAttribute('d', path);
                trailElement.setAttribute('stroke', atom.getColor());
                trailElement.setAttribute('stroke-width', '1');
                trailElement.setAttribute('fill', 'none');
                trailElement.setAttribute('opacity', '0.3');
                trailElement.setAttribute('class', 'evolution-trail');
                canvas.appendChild(trailElement);
              }
            });
          }

          // Piešiame ryšius (jei egzistuoja)
          this.atoms.forEach((atom) => {
            atom.links.forEach((linkId) => {
              const target = this.atoms.find((a) => a.id === linkId);
              if (target) {
                const line = document.createElementNS(
                  'http://www.w3.org/2000/svg',
                  'line'
                );
                line.setAttribute('x1', atom.state[0]);
                line.setAttribute('y1', atom.state[1]);
                line.setAttribute('x2', target.state[0]);
                line.setAttribute('y2', target.state[1]);
                line.setAttribute('stroke', atom.getColor());
                line.setAttribute('stroke-width', '1');
                line.setAttribute('opacity', '0.4');
                canvas.appendChild(line);
              }
            });
          });

          // Piešiame atomus
          this.atoms.forEach((atom) => {
            const circle = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'circle'
            );
            circle.setAttribute('cx', atom.state[0]);
            circle.setAttribute('cy', atom.state[1]);
            circle.setAttribute('r', atom.getSize());
            circle.setAttribute('fill', atom.getColor());
            circle.setAttribute('opacity', atom.getOpacity());
            circle.setAttribute('filter', 'url(#glow)');
            canvas.appendChild(circle);

            // Energijos indikatorius
            const energyRing = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'circle'
            );
            energyRing.setAttribute('cx', atom.state[0]);
            energyRing.setAttribute('cy', atom.state[1]);
            energyRing.setAttribute('r', atom.getSize() + 3);
            energyRing.setAttribute('fill', 'none');
            energyRing.setAttribute('stroke', atom.getColor());
            energyRing.setAttribute('stroke-width', '1');
            energyRing.setAttribute('opacity', atom.state[2] / 200);
            canvas.appendChild(energyRing);

            // Atom ID
            const text = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'text'
            );
            text.setAttribute('x', atom.state[0]);
            text.setAttribute('y', atom.state[1] - atom.getSize() - 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', 'rgba(255,255,255,0.8)');
            text.setAttribute('font-size', '8');
            text.setAttribute('font-weight', 'bold');
            text.textContent = atom.id;
            canvas.appendChild(text);

            // Metadata indikatorius
            const metaIcon = this.getMetadataIcon(atom.metadata);
            if (metaIcon) {
              const metaText = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'text'
              );
              metaText.setAttribute('x', atom.state[0] + atom.getSize() + 5);
              metaText.setAttribute('y', atom.state[1] + 3);
              metaText.setAttribute('text-anchor', 'start');
              metaText.setAttribute('fill', atom.getColor());
              metaText.setAttribute('font-size', '12');
              metaText.textContent = metaIcon;
              canvas.appendChild(metaText);
            }
          });

          // Atnaujinti statistikas
          this.updateUI();
        }

        getMetadataIcon(metadata) {
          const icons = {
            orbital_dancer: '🌀',
            energy_vampire: '🧛',
            gravity_well: '🕳️',
            wanderer: '🚶',
            cluster_former: '🔗',
            boundary_keeper: '🛡️',
          };
          return icons[metadata] || '⚛️';
        }

        updateStats(decisionType) {
          this.stats[`${decisionType}Actions`]++;
        }

        updateUI() {
          // Statistikų atnaujinimas
          document.getElementById('deterministicActions').textContent =
            this.stats.deterministicActions;
          document.getElementById('adaptiveActions').textContent =
            this.stats.adaptiveActions;
          document.getElementById('pseudoRandomActions').textContent =
            this.stats.pseudoRandomActions;

          // Vidutinė energija
          const avgEnergy =
            this.atoms.reduce((sum, atom) => sum + atom.state[2], 0) /
            this.atoms.length;
          document.getElementById('avgEnergy').textContent =
            avgEnergy.toFixed(1);

          // Aktyvūs ryšiai
          const totalLinks = this.atoms.reduce(
            (sum, atom) => sum + atom.links.length,
            0
          );
          document.getElementById('activeLinks').textContent = totalLinks;

          // Sistemos informacija
          const systemInfo = document.getElementById('systemInfo');
          const energyVariance = this.calculateEnergyVariance();
          const movementEnergy = this.calculateMovementEnergy();

          systemInfo.innerHTML = `
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>🌡️ Energijos variacija:</strong> ${energyVariance.toFixed(
                          1
                        )}
                    </div>
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>💨 Judėjimo energija:</strong> ${movementEnergy.toFixed(
                          1
                        )}
                    </div>
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>⚛️ Atomų skaičius:</strong> ${this.atoms.length}
                    </div>
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>🎯 Mutacijos:</strong> ${(
                          this.params.mutationRate * 100
                        ).toFixed(1)}%
                    </div>
                `;

          // Top atomų sąrašas
          const atomsList = document.getElementById('atomsList');
          const topAtoms = [...this.atoms]
            .sort((a, b) => b.state[2] - a.state[2])
            .slice(0, 8);

          atomsList.innerHTML = topAtoms
            .map(
              (atom) => `
                    <div class="atom-info">
                        <div style="display: flex; align-items: center; margin-bottom: 5px;">
                            <strong>Atomas ${atom.id}</strong>
                            <span style="margin-left: auto; font-size: 14px;">${this.getMetadataIcon(
                              atom.metadata
                            )}</span>
                        </div>
                        <div class="state-display">
                            <div class="state-val state-x">X: ${atom.state[0].toFixed(
                              0
                            )}</div>
                            <div class="state-val state-y">Y: ${atom.state[1].toFixed(
                              0
                            )}</div>
                            <div class="state-val state-energy">E: ${atom.state[2].toFixed(
                              0
                            )}</div>
                        </div>
                        <div class="links-display">
                            Ryšiai: ${
                              atom.links.length
                            } | Gravitacija: ${atom.state[3].toFixed(1)}
                        </div>
                        <div class="metadata-display">
                            ${atom.metadata} (${atom.lastDecisionType})
                        </div>
                        <div style="font-size: 9px; color: #aaa; margin-top: 4px;">
                            Amžius: ${atom.age} | Adaptacijos: ${
                atom.adaptationCount
              }
                        </div>
                    </div>
                `
            )
            .join('');
        }

        calculateEnergyVariance() {
          const avgEnergy =
            this.atoms.reduce((sum, atom) => sum + atom.state[2], 0) /
            this.atoms.length;
          const variance =
            this.atoms.reduce(
              (sum, atom) => sum + Math.pow(atom.state[2] - avgEnergy, 2),
              0
            ) / this.atoms.length;
          return Math.sqrt(variance);
        }

        calculateMovementEnergy() {
          return this.atoms.reduce((sum, atom) => {
            return (
              sum +
              Math.sqrt(
                atom.velocity[0] * atom.velocity[0] +
                  atom.velocity[1] * atom.velocity[1]
              )
            );
          }, 0);
        }
      }

      // Globalios kintamųjų ir funkcijų
      let system = new AtomChainSystem();

      function startEvolution() {
        system.evolutionRunning = true;
        system.evolve();
      }

      function pauseEvolution() {
        system.evolutionRunning = false;
      }

      function resetSystem() {
        system.evolutionRunning = false;
        system = new AtomChainSystem();
      }

      function addEnergyWave() {
        // Pridedame energijos bangą - visiems atomams
        const waveStrength = 50;
        const centerX = 500;
        const centerY = 300;

        system.atoms.forEach((atom) => {
          const distance = Math.sqrt(
            Math.pow(atom.state[0] - centerX, 2) +
              Math.pow(atom.state[1] - centerY, 2)
          );
          const energy = waveStrength * Math.exp(-distance / 200);
          atom.state[2] = Math.min(150, atom.state[2] + energy);

          // Spalvos kaita
          atom.state[4] = (atom.state[4] + energy) % 360;

          // Impulso pridėjimas
          const angle = Math.atan2(
            atom.state[1] - centerY,
            atom.state[0] - centerX
          );
          atom.velocity[0] += Math.cos(angle) * energy * 0.05;
          atom.velocity[1] += Math.sin(angle) * energy * 0.05;
        });

        system.render();
      }

      function createGravityWell() {
        // Sukuriame gravitacijos šulinį centre
        const wellX = 500;
        const wellY = 300;
        const wellStrength = 100;

        system.atoms.forEach((atom) => {
          const distance = Math.sqrt(
            Math.pow(atom.state[0] - wellX, 2) +
              Math.pow(atom.state[1] - wellY, 2)
          );

          if (distance < 200) {
            const pullStrength = wellStrength / (distance + 10);
            const angle = Math.atan2(
              wellY - atom.state[1],
              wellX - atom.state[0]
            );

            atom.velocity[0] += Math.cos(angle) * pullStrength * 0.01;
            atom.velocity[1] += Math.sin(angle) * pullStrength * 0.01;

            // Gravitacijos jėgos padidinimas
            atom.state[3] = Math.min(100, atom.state[3] + pullStrength * 0.1);
          }
        });
      }

      function toggleTrails() {
        system.showTrails = !system.showTrails;
        if (!system.showTrails) {
          // Išvalome trajektorijas
          system.atoms.forEach((atom) => {
            atom.trail = [];
          });
        }
        system.render();
      }

      // Parametrų valdymo funkcijos
      function updateMutation() {
        const slider = document.getElementById('mutationSlider');
        const value = document.getElementById('mutationValue');
        system.params.mutationRate = parseFloat(slider.value);
        value.textContent = slider.value;
      }

      function updateGravity() {
        const slider = document.getElementById('gravitySlider');
        const value = document.getElementById('gravityValue');
        system.params.gravity = parseFloat(slider.value);
        value.textContent = slider.value;
      }

      function updateDamping() {
        const slider = document.getElementById('dampingSlider');
        const value = document.getElementById('dampingValue');
        system.params.damping = parseFloat(slider.value);
        value.textContent = slider.value;
      }

      // Auto-start demonstracija
      setTimeout(() => {
        if (!system.evolutionRunning) {
          startEvolution();
        }
      }, 2000);
    </script>
  </body>
</html>
